// Prisma Schema for Vesla ERP
// Database: PostgreSQL
// Double-Entry Bookkeeping System

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USER MANAGEMENT & AUTHENTICATION
// ============================================

enum UserRole {
  ADMIN
  ACCOUNTANT
  MANAGER
  VIEWER
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  role      UserRole @default(VIEWER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  createdInvoices     Invoice[]        @relation("InvoiceCreatedBy")
  createdPayments     Payment[]        @relation("PaymentCreatedBy")
  createdTransactions Transaction[]    @relation("TransactionCreatedBy")
  auditLogs           AuditLog[]
  blacklistedTokens   TokenBlacklist[]
  reportedIssues      Issue[]          @relation("IssueReportedBy")
  assignedIssues      Issue[]          @relation("IssueAssignedTo")
  issueComments       IssueComment[]   @relation("IssueCommentUser")

  @@map("users")
}

// ============================================
// COMPANY & ORGANIZATION
// ============================================

model Company {
  id        String   @id @default(uuid())
  code      String   @unique
  name      String
  address   String?
  phone     String?
  email     String?
  taxNumber String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  accounts     Account[]
  invoices     Invoice[]
  payments     Payment[]
  transactions Transaction[]
  customers    Customer[]
  vehicles     Vehicle[]
  bookings     Booking[]

  @@map("companies")
}

model Customer {
  id           String  @id @default(uuid())
  companyId    String? // Optional - individual customers don't belong to a company
  code         String  @unique // Unique across all customers
  name         String // Full name
  firstName    String?
  lastName     String?
  email        String  @unique
  phone        String?
  mobileNumber String? // Mobile-specific number
  address      String?
  taxNumber    String?

  // KYC/Identity fields
  licenseNumber         String?
  licenseExpiry         DateTime?
  driversLicenseCountry String?
  emiratesId            String?   @unique
  passportNumber        String?   @unique
  passportCountry       String?
  nationality           String?
  dateOfBirth           DateTime?
  isTourist             Boolean   @default(false)

  // Payment card (last 4 digits only - PCI compliance)
  cardLast4      String?
  cardType       String? // Visa, Mastercard, etc.
  cardHolderName String?
  bankProvider   String?

  // KYC verification status
  kycVerified   Boolean   @default(false)
  kycVerifiedAt DateTime?

  // Authentication (customers can log in directly)
  passwordHash String?
  role         String? @default("CUSTOMER")

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  company  Company?  @relation(fields: [companyId], references: [id])
  invoices Invoice[]
  payments Payment[]
  bookings Booking[]

  @@index([email])
  @@index([emiratesId])
  @@index([passportNumber])
  @@map("customers")
}

// ============================================
// CHART OF ACCOUNTS
// ============================================

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

enum AccountSubType {
  // Assets
  CASH
  BANK
  ACCOUNTS_RECEIVABLE
  INVENTORY
  FIXED_ASSET
  OTHER_ASSET

  // Liabilities
  ACCOUNTS_PAYABLE
  SALARIES_PAYABLE
  TAX_PAYABLE
  LOAN
  OTHER_LIABILITY

  // Equity
  CAPITAL
  RETAINED_EARNINGS
  DRAWINGS

  // Revenue
  SALES
  SERVICE_REVENUE
  OTHER_REVENUE

  // Expenses
  COST_OF_GOODS_SOLD
  SALARY_EXPENSE
  RENT_EXPENSE
  UTILITY_EXPENSE
  OTHER_EXPENSE
}

model Account {
  id          String         @id @default(uuid())
  companyId   String
  code        String
  name        String
  type        AccountType
  subType     AccountSubType
  description String?
  parentId    String?
  isActive    Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  // Relations
  company          Company           @relation(fields: [companyId], references: [id])
  parent           Account?          @relation("AccountHierarchy", fields: [parentId], references: [id])
  children         Account[]         @relation("AccountHierarchy")
  transactionLines TransactionLine[]

  @@unique([companyId, code])
  @@map("accounts")
}

// ============================================
// DOUBLE-ENTRY BOOKKEEPING CORE
// ============================================

enum TransactionType {
  JOURNAL_VOUCHER
  INVOICE
  PAYMENT
  RECEIPT
  CONTRA
  ADJUSTMENT
}

enum TransactionStatus {
  DRAFT
  POSTED
  VOID
}

model Transaction {
  id          String            @id @default(uuid())
  companyId   String
  type        TransactionType
  status      TransactionStatus @default(DRAFT)
  number      String // JV-2025-001, INV-2025-001, etc.
  date        DateTime
  description String?
  reference   String? // External reference
  createdById String
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  postedAt    DateTime?

  // Relations
  company   Company           @relation(fields: [companyId], references: [id])
  createdBy User              @relation("TransactionCreatedBy", fields: [createdById], references: [id])
  lines     TransactionLine[]
  invoice   Invoice?
  payment   Payment?

  @@unique([companyId, number])
  @@index([companyId, type, date])
  @@index([createdById]) // Added index for user's transactions
  @@index([date]) // Added index for date-based queries
  @@map("transactions")
}

model TransactionLine {
  id            String   @id @default(uuid())
  transactionId String
  accountId     String
  description   String?
  debit         Decimal  @default(0) @db.Decimal(15, 2)
  credit        Decimal  @default(0) @db.Decimal(15, 2)
  lineNumber    Int
  createdAt     DateTime @default(now())

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  account     Account     @relation(fields: [accountId], references: [id])

  @@index([transactionId, lineNumber])
  @@map("transaction_lines")
}

// ============================================
// INVOICES
// ============================================

enum InvoiceStatus {
  DRAFT
  SENT
  PARTIALLY_PAID
  PAID
  OVERDUE
  VOID
}

model Invoice {
  id            String        @id @default(uuid())
  companyId     String
  customerId    String
  transactionId String        @unique
  invoiceNumber String
  invoiceDate   DateTime
  dueDate       DateTime
  status        InvoiceStatus @default(DRAFT)
  subtotal      Decimal       @db.Decimal(15, 2)
  taxAmount     Decimal       @default(0) @db.Decimal(15, 2)
  totalAmount   Decimal       @db.Decimal(15, 2)
  paidAmount    Decimal       @default(0) @db.Decimal(15, 2)
  balanceAmount Decimal       @db.Decimal(15, 2)
  notes         String?
  createdById   String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  company     Company       @relation(fields: [companyId], references: [id])
  customer    Customer      @relation(fields: [customerId], references: [id])
  transaction Transaction   @relation(fields: [transactionId], references: [id])
  createdBy   User          @relation("InvoiceCreatedBy", fields: [createdById], references: [id])
  items       InvoiceItem[]
  payments    Payment[]
  booking     Booking?

  @@unique([companyId, invoiceNumber])
  @@index([companyId, customerId, status])
  @@index([invoiceDate]) // Added index for date-based queries
  @@index([dueDate]) // Added index for due date queries
  @@map("invoices")
}

model InvoiceItem {
  id          String   @id @default(uuid())
  invoiceId   String
  description String
  quantity    Decimal  @db.Decimal(15, 2)
  unitPrice   Decimal  @db.Decimal(15, 2)
  amount      Decimal  @db.Decimal(15, 2)
  lineNumber  Int
  createdAt   DateTime @default(now())

  // Relations
  invoice Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  @@index([invoiceId, lineNumber])
  @@map("invoice_items")
}

// ============================================
// PAYMENTS
// ============================================

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  CREDIT_CARD
  OTHER
}

enum PaymentStatus {
  DRAFT
  POSTED
  RECONCILED
  VOID
}

model Payment {
  id            String        @id @default(uuid())
  companyId     String
  customerId    String?
  invoiceId     String?
  transactionId String        @unique
  paymentNumber String
  paymentDate   DateTime
  amount        Decimal       @db.Decimal(15, 2)
  method        PaymentMethod
  status        PaymentStatus @default(DRAFT)
  reference     String? // Cheque number, transaction ID, etc.
  notes         String?
  createdById   String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  company     Company     @relation(fields: [companyId], references: [id])
  customer    Customer?   @relation(fields: [customerId], references: [id])
  invoice     Invoice?    @relation(fields: [invoiceId], references: [id])
  transaction Transaction @relation(fields: [transactionId], references: [id])
  createdBy   User        @relation("PaymentCreatedBy", fields: [createdById], references: [id])

  @@unique([companyId, paymentNumber])
  @@index([companyId, customerId, status])
  @@index([paymentDate]) // Added index for date-based queries
  @@map("payments")
}

// ============================================
// AUDIT & LOGGING
// ============================================

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  POST_TRANSACTION
  VOID_TRANSACTION
}

model AuditLog {
  id        String      @id @default(uuid())
  userId    String
  action    AuditAction
  entity    String // Table name
  entityId  String // Record ID
  oldValue  Json?
  newValue  Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime    @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([entity, entityId])
  @@index([createdAt]) // Added standalone index for time-based queries
  @@map("audit_logs")
}

// ============================================
// TOKEN BLACKLIST (for JWT revocation)
// ============================================

model TokenBlacklist {
  id        String   @id @default(uuid())
  token     String   @unique // The JWT token to blacklist
  userId    String // User who owned this token
  expiresAt DateTime // When the token would have expired naturally
  reason    String? // Why the token was blacklisted (logout, user deactivated, etc.)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([expiresAt]) // For cleanup jobs
  @@index([userId]) // For finding user's blacklisted tokens
  @@map("token_blacklist")
}

// ============================================
// VEHICLE RENTAL SYSTEM
// ============================================

enum VehicleStatus {
  AVAILABLE
  RENTED
  MAINTENANCE
  RETIRED
}

model Vehicle {
  id          String  @id @default(uuid())
  companyId   String
  make        String // e.g., "Nissan"
  model       String // e.g., "Sunny"
  year        Int // e.g., 2024
  plateNumber String  @unique // License plate
  vin         String? @unique // Vehicle Identification Number
  color       String?
  category    String? // Sedan, SUV, Luxury, etc.

  // Rental rates
  dailyRate   Decimal  @db.Decimal(15, 2)
  weeklyRate  Decimal? @db.Decimal(15, 2) // 7-day rate
  monthlyRate Decimal  @db.Decimal(15, 2) // 30-day rate

  // Vehicle specifications
  mileage      Int?    @default(0)
  fuelType     String? // Petrol, Diesel, Electric, Hybrid
  transmission String? // Automatic, Manual
  seats        Int? // Number of seats

  // Status and availability
  status   VehicleStatus @default(AVAILABLE)
  isBooked Boolean       @default(false) // Quick availability flag

  imageUrl    String?
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  company  Company   @relation(fields: [companyId], references: [id])
  bookings Booking[]

  @@index([companyId, status])
  @@index([make, model, year])
  @@index([status, isBooked]) // For availability queries
  @@map("vehicles")
}

enum BookingStatus {
  PENDING // Awaiting confirmation
  CONFIRMED // Booking confirmed
  ACTIVE // Vehicle picked up
  COMPLETED // Vehicle returned
  CANCELLED // Booking cancelled
}

model Booking {
  id             String        @id @default(uuid())
  companyId      String
  vehicleId      String
  customerId     String
  invoiceId      String?       @unique // Link to generated invoice
  bookingNumber  String // BK-2025-0001
  startDate      DateTime
  endDate        DateTime
  totalDays      Int // Calculated: endDate - startDate
  monthlyPeriods Int           @default(0) // Number of 30-day periods
  remainingDays  Int           @default(0) // Days after monthly periods
  dailyRate      Decimal       @db.Decimal(15, 2) // Rate at time of booking
  weeklyRate     Decimal?      @db.Decimal(15, 2) // Weekly rate at booking
  monthlyRate    Decimal       @db.Decimal(15, 2) // Rate at time of booking
  totalAmount    Decimal       @db.Decimal(15, 2) // Calculated total
  status         BookingStatus @default(PENDING)

  // Location and logistics
  pickupLocation  String?
  dropoffLocation String?

  // Payment and terms
  paymentMethod String? // CASH, CREDIT_CARD, BANK_TRANSFER, etc.
  termsAccepted Boolean @default(false)

  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  company  Company        @relation(fields: [companyId], references: [id])
  vehicle  Vehicle        @relation(fields: [vehicleId], references: [id])
  customer Customer       @relation(fields: [customerId], references: [id])
  invoice  Invoice?       @relation(fields: [invoiceId], references: [id])
  addOns   BookingAddOn[]

  @@unique([companyId, bookingNumber])
  @@index([vehicleId, startDate, endDate])
  @@index([customerId])
  @@index([status])
  @@map("bookings")
}

// Booking add-ons (GPS, insurance, child seat, etc.)
model BookingAddOn {
  id          String   @id @default(uuid())
  bookingId   String
  addonName   String // GPS, Child Seat, Insurance, etc.
  dailyRate   Decimal  @db.Decimal(15, 2)
  quantity    Int      @default(1) // Usually number of days
  totalAmount Decimal  @db.Decimal(15, 2)
  createdAt   DateTime @default(now())

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@index([bookingId])
  @@map("booking_addons")
}

// ============================================
// ISSUE TRACKING SYSTEM
// ============================================

enum IssuePriority {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum IssueStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
  REOPENED
}

enum IssueType {
  BUG
  FEATURE_REQUEST
  SUPPORT
  SECURITY
  PERFORMANCE
  OTHER
}

model Issue {
  id          String        @id @default(uuid())
  title       String
  description String
  type        IssueType
  priority    IssuePriority @default(MEDIUM)
  status      IssueStatus   @default(OPEN)

  // Issue tracking
  reportedById  String // User who reported the issue
  assignedToId  String? // User assigned to resolve the issue

  // Metadata
  environment   String? // production, staging, development
  affectedUrl   String? // URL where issue occurred
  stackTrace    String? // Error stack trace if applicable
  browserInfo   String? // Browser/device information

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  resolvedAt DateTime?

  // Relations
  reportedBy User         @relation("IssueReportedBy", fields: [reportedById], references: [id])
  assignedTo User?        @relation("IssueAssignedTo", fields: [assignedToId], references: [id])
  comments   IssueComment[]

  @@index([status, priority])
  @@index([reportedById])
  @@index([assignedToId])
  @@index([type])
  @@index([createdAt])
  @@map("issues")
}

model IssueComment {
  id        String   @id @default(uuid())
  issueId   String
  userId    String
  comment   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  issue Issue @relation(fields: [issueId], references: [id], onDelete: Cascade)
  user  User  @relation("IssueCommentUser", fields: [userId], references: [id])

  @@index([issueId, createdAt])
  @@map("issue_comments")
}
